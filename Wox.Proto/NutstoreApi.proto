syntax = "proto3";

package api;

message SearchRequest {
  // Query should be split by white space
  //  and then each part is a query term
  // For example, the query " Why so \t so serious  " contain three query terms (sort-dedup):
  //    "Why"
  //    "so"
  //    "serious"
  // And the query term case sensitivity can be determined by is there any character is upper case
  //  so we get the final result:
  //    ("Why", true)
  //    ("so", false)
  //    ("serious", false)
  message QueryTerm {
    string term = 1;
    bool case_sensitive = 2;
  }

  repeated QueryTerm terms = 1;
  // Used to strip the given prefix for data in LMDB before matching
  //  if a value in LMDB is not have the given prefix, it's considered as not a match
  // This prefix can be used to narrow down to match a subset of the dataset in LMDB
  //  if you want to match all data in LMDB, pass an empty string for this argument
  //  in such case, all matched items will have the full data returned
  // NOTE: if it is not empty, it should ends with os-specific path separator
  //  e.g. /foo/bar/, D:\foo\bar\
  string prefix_mask = 2;
  // Whether to include the matched positions in search response
  //  i.e. you can use the positions to do things like highlighting
  bool with_pos = 3;
  // 1<<0: FLAG_NEED_FILE
  // 1<<1: FLAG_NEED_DIR
  // Zero flag or unknown flags are not allowed
  uint32 flags = 4;
}

enum DbType {
  HISTORY = 0;
  WS = 1;
  FS = 2;
}

message SearchResponse {
  message SearchResult {
    // Where the data set the matched result belongs to
    uint32 db_idx = 1;
    DbType db_type = 2;
    uint64 key = 3;
    bytes val = 4;
    int32 score = 5;
    // uint32 for position index is sufficient
    repeated uint32 pos = 6;
  }
  // The search results are not sorted
  repeated SearchResult results = 1;
}

message UpdateRequest {
  message UpdateArgs {
    uint32 db_idx = 1;
    DbType db_type = 2;
    uint64 key = 3;
    bytes val = 4;
    bool deleted = 5; // If deleted=true, val should be empty. (i.e. delete by key)
  }
  repeated UpdateArgs args = 1;
}

message UpdateResponse {
  // Currently empty
}

message PurgeRequest {
  uint32 db_idx = 1;
  repeated DbType db_type = 2;
}

message PurgeResponse {
  // Currently empty
}

// Query LMDB stat info (mainly used for debugging)
message StatRequest {
  // Currently empty
}

message StatResponse {
  // http://www.lmdb.tech/doc/group__mdb.html#structMDB__envinfo
  message EnvInfo {
    uint64 used_map_size = 1;
    uint64 map_size = 2; // mdb_env_set_mapsize()
    uint64 last_pgno = 3;
    uint64 last_txnid = 4;
    uint32 max_readers = 5;
    uint32 num_readers = 6;
  }
  // http://www.lmdb.tech/doc/group__mdb.html#structMDB__stat
  message Stat {
    uint32 db_idx = 1;
    DbType db_type = 2;

    uint32 page_size = 3;
    uint32 depth = 4;
    uint64 branch_pages = 5;
    uint64 leaf_pages = 6;
    uint64 overflow_pages = 7;
    uint64 entries = 8;
  }
  EnvInfo env_info = 1;
  repeated Stat stats = 2;
}

service ApiService {
  rpc Search(SearchRequest) returns (stream SearchResponse); // Streaming search API
  rpc Update(UpdateRequest) returns (UpdateResponse);
  rpc Purge(PurgeRequest) returns (PurgeResponse);
  rpc Stat(StatRequest) returns (StatResponse);
}
